<?xml version="1.0"?>
<package >
  <metadata>
    <id>$id$</id>
    <version>$version$</version>
    <title>$title$</title>
    <authors>Unterrainer Informatik OG Team</authors>
    <owners>Public Domain</owners>
    <licenseUrl>http://unlicense.org</licenseUrl>
	<iconUrl>https://github.com/UnterrainerInformatik/FiniteStateMachine/raw/master/MonoGameStateMachine/icon.png</iconUrl>
    <projectUrl>https://github.com/UnterrainerInformatik/FiniteStateMachine</projectUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>
			[DEPRECATED] This library is deprecated. Please use the normal StateMachine instead which is fully tested and being actively maintained. https://www.nuget.org/packages/StateMachine/
			This project implements a Finite-State-Machine (FSM) designed to be used in games.
			Furthermore it implements even a Stack-Based-FSM (SBFSM). So you may tell it to 'continue with the last state before the active one'.
			You describe your FSM using a nice and well documented DSL (Domain Specific Language).

			This machine also adds the function '.After(time)' to transitions so you can set timed transitions that don't necessarily have to have a trigger at all.

			This replaces the code we usually had for keyboard-input (run-left-right-duck-jump), clicked buttons on the GUI (idle-over-down-refreshing), tower-states (idle-aiming-firing-reloading) or for the connection procedure when setting up peer2peer connections in our games....
			This is a PCL (portable code library) so you should be able to use it in any of your MG projects.
		</description>
    <summary>
			[DEPRECATED] This library is deprecated. Please use the normal StateMachine instead which is fully tested and being actively maintained. https://www.nuget.org/packages/StateMachine/
			This project implements a Finite-State-Machine (FSM) designed to be used in games.
			Furthermore it implements even a Stack-Based-FSM (SBFSM). So you may tell it to 'continue with the last state before the active one'.
		</summary>
    <releaseNotes>
			[DEPRECATED] This library is deprecated. Please use the normal StateMachine instead which is fully tested and being actively maintained. https://www.nuget.org/packages/StateMachine/ nuget.org -> search for 'Unterrainer' or StateMachine.
			The new version there has been updated to host the same functionality as this version here did. You just have to feed it a TimeSpan on Update() like so: Update(TimeSpan.FromMilliseconds(gameTime.ElapsedGameTime.TotalMilliseconds));
		</releaseNotes>
    <copyright>Copyright 2017</copyright>
    <language>en-US</language>
    <tags>state finite machine gamestate transition fluent gametime monogame mg after timer</tags>
  </metadata>
</package>